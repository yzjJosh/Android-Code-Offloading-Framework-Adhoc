In previous 2 weeks we have analyzed the performance of our project. We have concluded that our framework works best in applications that satisfy 2 properties: 1. contains multiple threads. 2. migrated method has time complexity greater than O(N). We have created a NQueenSolver application which satisfies the previous properties and measure its performance. We found that when the problem size is big enough, our framework can significantly boost the speed of this application.

It is obvious that our framework cannot help applications that only has single thread. That is because transmitting data from one device to another device will cause extra overhead. Suppose the time needed to execute a method m is T, the overhead of transmitting data is T’. If m is migrated to another device with same computational power, the new device also needs to spend time T to execute this method. Then from local device’s perspective, the method execution spends T + T’ time. If the application only has single thread, then the local device does nothing while waiting the remote device, thus the total time to execute this program is longer.

Things become different if the application contains multiple threads. In multi-thread programs, local device can run other threads while waiting for the migrated method. In this way the migrated method and other threads runs in parallel. Suppose the time to execute method m is still T, and the time to execute other threads is S. In a single core device, the total time to run all these threads is T + S. If the method m is migrated to another device with same computational power, then the local device spends T’ extra time to transmit data. After data is sent to remote device, the local device can switch to another thread and run it while the remote device is executing method m. If S > T (which is often the case because it is unlikely to migrate most computation to other devices), remote device will complete execution firstly, then the total time to run the entire program is S + T’. It is obvious that when T’ < T, the overall time will be shorter, and the entire performance is improved. Moreover, the data transmission overhead is linear to the data size N, thus T’(N) = O(N). So we conclude that when T(N) > T’(N) = O(N), the overall performance will be improved. In other words, when the overhead is less than the method execution time, migrating that method will increase the overall performance.

In order to show that our framework can indeed improve performance, we create a NQueenSolver application which solves N Queen problem using N threads. Node that the time complexity of N Queen problem is O(N^N), which is greater than O(N). We divide the solution space to N parts and use N threads to search each space. For each thread, we mark the method as remotable and run the application on 1 to 3 nodes. Our test results can be found in NQueenSolverTestResults.xls. From the result, it is clear that when N >= 13, the time spend on entire program is significantly reduced on multiple devices. However, when N is small (N < 13), single device has best performance. That is because in this case the time spent to solve N Queen problem is less than the time spent to transmit data to another device.