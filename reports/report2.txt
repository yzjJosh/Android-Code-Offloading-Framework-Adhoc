In previous 2 weeks we have completed all the tasks defined in tasks2.txt. We have implemented a gradle plugin to insert offloading logics at build time. We also have modified the example apps to prove that our plugin works well. Additionally, we have modified two open source Android applications to show that our plugin works well in real-life Android applications. Moreover, we have optimized the object synchronization process to reduce memory usage and communication overhead.

Our gradle plugin is based on Morpheus (https://github.com/stephanenicolas/morpheus), an open source gradle plugin to transform class files during Android build processes. It uses Javaassist to manipulate Java bytecode, and provides simple APIs to customize the class transformation process. The Android process has two phases. Firstly all source code are compiled into .class files using java compiler. Then these .class files are translated to .dex files, which are executable files in Android environment. What Morpheus does is manipulating class files before they are translated to dex files. It inserts a new gradle task between these two phases. In this way we can weave our offloading logics to target methods at build time.

We have performed 3 types of weaving in the build process. They are initialization, class transformation, and method transformation. Firstly, we need to weave initialization code into the Android applications. What we do is finding all the classes which extends Context class and insert initialization code into their constructors. Because Android application has to instantiate these Context classes before it starts to run, we can ensure that the initialization code are always executed before application starts. The second type is class transformation. We need to transform classes because an object needs to implement Serializable interface in order to be transmitted via network. So we check all the user-defined classes and make them Serializable. The third type is method transformation. We have provided an annotation @Remote to mark a method as a target method. For every target method we will weave some offloading logic into it in order to perform code offloading. After all these transformations are performed, the application will be ready to run in a distributed manner.

Optionally user can provide a listener to a target method. They only need to specify the listener class as a parameter of @Remote annotation (e.g. @Remote(listener = MyListener.class)). Then when the target method starts migration or completes migration the listener will be triggered. In this way user can monitor the remote execution process. We also provide another annotation @Ignore which can specify that a class field needs to be ignored. If a field is to be ignored, we will not send it to the server (similar to Java “transient” keyword, but we use @Ignore for some design reasons).

In addition to the gradle plugin, we have also optimized the object migration process. Previously we will send all related objects to the server, and server will send all these objects back to the client, then perform object synchronization on client-side. That will waste a lot of time if no objects are modified on the server side. For example, set.contains(Object o) method does not modify the set. It only checks if object exists in the set. So there is no need to send back the whole set. The case can be more complicated if only minor parts of an object are modified while most parts are unchanged. To solve this problem, we implement an object-diff mechanism which can compute the difference of an object after a method execution. It records only the “dirty fields” of an object. So after a method is executed, we only send back the differences of objects. When the client receives the differences, client will apply transformation based on the differences to synchronize with remote objects. In this way we can save a lot of communication overhead when only minor parts of objects are modified.

To test our plugin, we have modified previous examples and found that they all work well. We also tried our plugin in two real-life applications: a flutter-cow game and a sudoku game. The flutter-cow game is something like the flappy bird game. You need to control a cow and make it jumping to avoid hitting barriers. We have migrated the move method to the server. The move method will compute the next coordination (x and y value) of an object. Our test shows that the move method works correctly even if it is migrated to the server. Another app is a sudoku game, where we migrate a completion check method to server. Our test shows that the method works correctly on the server and successfully check the game status when a sudoku is solved.