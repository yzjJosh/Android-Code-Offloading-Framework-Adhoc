In previous 2 weeks we have completed all tasks defined in tasks3.txt. Firstly we have improved the server app so that user can easily control the server and monitor the server status. Then we have implemented some new mechanisms so that server nodes can be added to and removed from the system dynamically. Finally, we have tested our system using the example apps to show that our system now can run on multiple servers dynamically.

Previously the server app cannot be stopped after it starts. In order to stop a server, we have to kill the process via operating system. Also the server app does not have any GUI so that we cannot view server logs directly in the screen. We have to connect the Android device to a computer to view the logs. After our upgrading, now the server app has a switch button to start or stop the server dynamically. Also we have implemented a console view in the server app to show the logs of server. The console is based on GitHub project https://github.com/jraska/Console. We integrate the Console view into Timber (https://github.com/JakeWharton/timber) logger so that program logs are printed in the console view. This approach greatly reduce the efforts to debug the system.

Another thing we have done is introducing a new mechanism to add or remove server nodes dynamically. Previously the server nodes are encoded in the clients’ source code. We specify the IP address and port number of all available server nodes in the app’s source code. However this approach is impossible for a production because the server nodes have dynamic IP addresses. An Android device may have different IP addresses in different networks. Also the server node may crash in some cases, like the phone is power off or the process is killed by OS. Thus we need a way to dynamically configure the server nodes.

To solve this problem, we have introduced a central server node, which has static IP address all the time. Every client and server can communicate with the central server. We maintain a list of available server nodes inside the central server. When a new server node starts, it will register itself in the central server. When a client starts, it will retrieve the server list from the central server. Afterwards clients will keep synchronization with the central server so that it has the newest server list all the time. Each server will keep a heart-beating with the central server node. If a server stops, the heart-beating will stops. When the central server does not receive heart-beating after certain time period, it will remove that server from the list. In this way the servers can be added or removed dynamically without any need of reconfiguration.

Our central server code is written in Java and is deployed in an AWS EC2 instance. We have tested it with the example apps and shows that they work correctly with 2 server nodes and 2 client nodes. Our two server nodes are an Android phone and an Android Virtual Machine inside a desktop. Firstly we only open one server node, in this case the client works correctly with this server. Then we open another server node, after a short time (about 5 seconds) the client is notified about the new server node and start using the new node as a server during its computation. Then we add another client, which also correctly detects the two server nodes and use both of them in its computation. When we close one server node, the central server successfully detects it and remove that server from its list. Then the clients works well using the remaining server node in its computation.