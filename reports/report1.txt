In previous two weeks we have completed most task requirements. We have developed an Android library and an Android server App. The library includes the key components for code offloading, while the server App provides APIs to compute methods remotely. Due to the time limitation, we only wrote 2 testing Apps instead of 5. But they are enough to show that our framework can migrate the execution of arbitrary method to server.

The library provides core logics for method offloading. When a method wants to be executed in the server, firstly it will check if current method can be migrated. We provide APIs to make such judgement based on the availability of servers and the properties of this invocation. If this method can be invoked remotely, then client will issue an request to the server. It will send the method name, declaring class name, arguments, and the invoking object to the server. If the server already has application bytecode, it will invoke the method directly and return back the return values together with the invoker and arguments. If the server does not have application bytecode, it will return an error message which tells the client to send the bytecode to server. After that, the server will retry this execution.

Though this process sounds very easy, there are a lot of challenges. The first challenge is to decide which server to execute a method. Suppose a client has 2 available servers, our current implementation will choose servers in a round-robin manner. The server-selection strategy has a huge influence on system’s load balancing performance. By providing a round-robin schedule, we can provide basic load balancing. However this round-robin strategy is only in local perspective. We cannot make sure that the loads are balanced in system perspective. We will dive deep in this topic later.

Another challenge is to synchronize remote objects. We have to synchronize objects because we have to make sure that executing a method remotely and locally results in same object relationships. Suppose we have two linked list nodes and a method to connect them together. If we run this method locally, these two nodes will connect with each other. But if we run them remotely, they will be connected in the server, and the local copies are still unconnected. Even if we receive them back from server, the original local nodes are still disconnected. We have to reconnect these local nodes to make sure that they have exactly the same structure as remote nodes. These logics are implemented in a class called ObjectMigrator. Because Java objects are referred by pointers, we can view them as a directed graph. When an object is sent to server, ObjectMigrator will keep an unique id for this object. When the object is received back from server, ObjectMigrator will make a depth-first-search on the received object and connect local objects in the same way. After this step the local objects will have exactly the same topological structure as remote objects. 

However, this synchronization strategy only ensures that data are consistent after method execution. We do not provide any guarantee of data consistency during method execution. So if an remote object is accessed by a local thread, the value may be wrong. We do not do it because data consistency in distributed system is very difficult and may cause huge overhead. If a method relies on shared variable, it should not be migrated. Even if we provide runtime data consistency, accessing shared variable will require a lot of network communications thus damage the overall performance gain. 

The third challenge is to load Android code dynamically. Android use Dalvik bytecode instead of Java bytecode, so we have to use Android specific class loader to load classes. General Android class loader only allows us to load an APK file which contains single dex file. However recent Android applications usually contains more than one dex file. Especially for “instant-run” applications, which may contain more than 10 dex files inside its APK package. To solve this problem, we firstly extract dex files from APK file, then load these dex files one by one to the class loader. In this way we successfully load Android classes from Android APK packages.

We have written 2 Android applications to test our library. The first application is a simple HelloWorld application which has a method HelloWorld to return a string. We use our framework to successfully invoke this method in an Android virtual machine from a smartphone. We are able to receive back the “Hello World” string. However the remote execution has worse performance. Local invocation takes 1 milliseconds while remote execution takes 124 milliseconds. The second application is a matrix multiplication application. In the application we try to multiply two matrices using multi-threads. Each thread calculates one row for the result. We migrated the row-calculating method to the Android virtual machine and performed truly distributed computing. During our tests the matrix can be computed correctly with collaboration of both local smartphone and remote server. However the performance of distributed computing is still worse. The local computation takes 150 milliseconds, while collaboration computation takes 5 seconds. The main reason for the performance penalty is due to data transmission. Our code is not optimized for distributed computing, so the data transmission overhead is huge. Another reason is that it is a linear time problem so the performance gain achieved by paralyzation does not supersedes the data transmission overhead. 

Currently developers have to manually insert offloading logics to method. However our next plan is to use bytecode manipulation to insert these logics automatically. In the next two weeks we plan to write a gradle plugin which can be included in Android build process to automate the code transformation. After that, developers only need to add annotations on target methods. Everything else will be handled by the plugin.

